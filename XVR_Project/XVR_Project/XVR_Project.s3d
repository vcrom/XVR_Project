/* Include s3d symbols */
#include <Script3d.h>
<<<<<<< HEAD
#include <Camera.s3d.h>
#include "spot_light.s3d"
=======
#include "Camera.s3d"
>>>>>>> 5eed2942e963f2cdbd97db0c29244edae92388f7
//#include "sys_camera.s3d"

/* Set global scene parameters */
SET SCENE_FOV  = 60;
SET SCENE_NEAR = 0.5;
SET SCENE_FAR  = 1000; 


// TODO: put your global variables here


/* Light globals */
var Light0;
var PosL = [0.0, 10.0, 10.0];	// default light position

/* Function declarations */
function DrawTerrain();
function build_wall_list();
function build_floor_list();


/* Other globals */
var map = "map.txt";
var crate = "crate.jpg";
var wall = "wall.png";
var grass = "grass.png";
var mesh_src = "object.aam";
<<<<<<< HEAD
var light_mesh = "lamp.AAM";

function OnDownload()
{
	FileDownload(file_name);
	FileDownload(text_src);
	FileDownload(mesh_src);
	FileDownload(light_mesh);
	
}
=======
>>>>>>> 5eed2942e963f2cdbd97db0c29244edae92388f7

var wall_texture;
var grass_texture;

var wall_list;
var floor_list;

var height;

function OnDownload() {
	FileDownload(map);
	FileDownload(mesh_src);
	
	FileDownload(grass);
	FileDownload(wall);
}

function OnInit(params) {
	CameraInit();
	
	/* initialize light */
	/*
	Light0 = CVmLight();
	Light0.SetPosition(PosL);
	Light0.SetDiffuse(1, 1, 1);
	Light0.Enable();
	*/
	Light0 = SpotlLight();
	var Lpo = [0,2,-10];
	Light0.Initialize(Lpo);
	
	var l_mesh = CVmNewMesh(light_mesh);
	//l_mesh.Normalize(2); 
	Light0.SetRenderableObject(l_mesh);//CVmObj(l_mesh));
	
	var tmp = LoadFile(map);
   	height = array(0);
   	for (var i = 0; i < Len(tmp); ++i) {
   		var line = Split(tmp[i], " ");
   		aadd(height, line);
   	}
   	
	wall_texture = CVmTexture(wall);
	grass_texture = CVmTexture(grass);
	
	build_wall_list();
	build_floor_list();
	
	var m_mesh = CVmNewMesh(mesh_src); // The mesh is created from the specified AAM file
   	//m_mesh.CenterBoundingBox();      // Mesh geometry is translated so as to put the origin in the center of the mesh bounding box
   	m_mesh.Normalize(10); 
   	global my_obj = CVmObj(m_mesh);
   	my_obj.SetPosition(Lpo[0], Lpo[1], Lpo[2]+10);
}



function OnFrame() {
	/* manage camera */
	CameraMoveMouse(height);

	SceneBegin();

	//DrawGrid([0.5, 0.5, 0.5], 100);
	DrawTerrain();
	//if(FileExists(map)) {
		//var file_string = LoadFile(map);
		//var file_string = FileRead(map);
		//ConsoleText(0.01,0.86,file_string[0]);
	//}
	
	
	
	// TODO: put your drawing code here


<<<<<<< HEAD
	SetActiveTexture(my_texture_foo); 
      glEnable(GL_TEXTURE_2D);
      glBegin(GL_QUADS);
         glNormal(0,0,1);      
         glTexCoord(0,1); 
         glVertex(0,0,0);         
         glTexCoord(1,1);
         glVertex(10,0,0);      
         glTexCoord(1,0);
         glVertex(10,10,0);      
         glTexCoord(0,0);
         glVertex(0,10,0);      
      glEnd(); 
      
    glPolygonOffset(1.5, 2);
    my_obj.Draw();
    Light0.Render();
=======
    //my_obj.Draw();
>>>>>>> 5eed2942e963f2cdbd97db0c29244edae92388f7
	SceneEnd();
}



function DownloadReady(RequestID)
{
	// TODO
}



function OnTimer()
{
	// TODO:
}


function OnEvent(eventID, wparam, lparam){
	// TODO: put your events handling code here
}

function OnError(){
	// TODO: put your errors handling code here
}

function OnExit()
{
	// TODO: put your cleanup code here
}


function DrawTerrain() {
	/* let's not mess up current OpenGL status */
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	
	glDisable(GL_LIGHTING);

	glEnable(GL_TEXTURE_2D);
	SetActiveTexture(grass_texture, VR_BILINEAR_FILTER, 0);
	glCallList(floor_list);
	
	SetActiveTexture(wall_texture, VR_FORCE_TEXTURE, 0);
	glCallList(wall_list);
	
	/* polite restoration of previous OpenGL status */
	glPopAttrib();
}


function build_floor_list() {
	var multiplier = 2.0;

	floor_list = glGenLists(1);
	glNewList(floor_list, GL_COMPILE);
	glBegin(GL_TRIANGLES);
		for (var i = 0; i < Len(height); ++i) {
			for (var j = 0; j < Len(height[i]); ++j) {
				glTexCoord(0,0); 
				glVertex(multiplier*i,     val(height[i][j]), multiplier*j);
				glTexCoord(0,1); 
				glVertex(multiplier*i,     val(height[i][j]), multiplier*(j+1));
				glTexCoord(1,0); 
				glVertex(multiplier*(i+1), val(height[i][j]), multiplier*j);
				
				glTexCoord(0,1); 
				glVertex(multiplier*i,     val(height[i][j]), multiplier*(j+1));
				glTexCoord(1,1); 
				glVertex(multiplier*(i+1), val(height[i][j]), multiplier*(j+1));
				glTexCoord(1,0); 
				glVertex(multiplier*(i+1), val(height[i][j]), multiplier*j);
			}
		}
	glEnd();
	glEndList();
	outputln("\nwall list = ", floor_list);
}

function build_wall_list() {
	var multiplier = 2.0;
	
	wall_list = glGenLists(1);
	glNewList(wall_list, GL_COMPILE);
	glBegin(GL_TRIANGLES);
		for (var i = 0; i < Len(height); ++i) {
			for (var j = 1; j < Len(height[i]); ++j) {
				if (height[i][j] != height[i][j-1]) {
					var size = abs(val(height[i][j]) - val(height[i][j-1]))/multiplier; 
					glTexCoord(1,0); 
					glVertex(multiplier*(i+1), val(height[i][j-1]), multiplier*j);
					glTexCoord(0,0); 
					glVertex(multiplier*i,     val(height[i][j-1]), multiplier*j);
					glTexCoord(0,size); 
					glVertex(multiplier*i,     val(height[i][j]),   multiplier*j);
					
					glTexCoord(1,0); 
					glVertex(multiplier*(i+1), val(height[i][j-1]), multiplier*j);
					glTexCoord(0,size); 
					glVertex(multiplier*i,     val(height[i][j]),   multiplier*j);
					glTexCoord(1,size); 
					glVertex(multiplier*(i+1), val(height[i][j]),   multiplier*j);
				}
			}
		}
		
		for (var i = 1; i < Len(height); ++i) {
			for (var j = 0; j < Len(height[i]); ++j) {
				if (height[i][j] != height[i-1][j]) {
					var size = abs(val(height[i][j]) - val(height[i-1][j]))/multiplier; 
					glTexCoord(0,0); 
					glVertex(multiplier*i, val(height[i-1][j]), multiplier*j);
					glTexCoord(0,1); 
					glVertex(multiplier*i, val(height[i-1][j]), multiplier*(j+1));
					glTexCoord(size,0); 
					glVertex(multiplier*i, val(height[i][j]),   multiplier*j);
					
					glTexCoord(size,0); 
					glVertex(multiplier*i, val(height[i][j]),   multiplier*j);
					glTexCoord(0,1); 
					glVertex(multiplier*i, val(height[i-1][j]), multiplier*(j+1));
					glTexCoord(size,1); 
					glVertex(multiplier*i, val(height[i][j]),   multiplier*(j+1));
				}
			}
		}
	glEnd();
	glEndList();
	outputln("\nfloor list = ", wall_list);
}