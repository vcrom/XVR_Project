/* Include s3d symbols */
#include <Script3d.h>
#include "SpotLight.s3d"

#include "Camera.s3d"
#include "SkyBox.s3d"
#include "Terrain.s3d"

/* Set global scene parameters */
SET SCENE_FOV  = 60;
SET SCENE_NEAR = 0.5;
SET SCENE_FAR  = 1000; 


// TODO: put your global variables here


/* Light globals */
var Light0; //spot light¿?
var PosL = [SCENE_FAR/2, SCENE_FAR/2, -SCENE_FAR/2];	// default light position
var Sun;

/* Other globals */
var map = "map.txt";
var crate = "crate.jpg";
var mesh_src = "object.aam";

var light_mesh = "lamp.AAM";

//Selecction
var selectabe_objects;
var selected;
var scaling;
var selected_mat;
var unselected_mat;
var onMouseL;
var onMouseR;

//Skybox
var skybox_files = {"skybox\\negx.png", "skybox\\negy.png", "skybox\\negz.png", "skybox\\posx.png", "skybox\\posy.png", "skybox\\posz.png"};
var sky_box;

//Terrain
var wall = "wall.png";
var grass = "grass.png";
var height;
var renderable_terrain;

function OnDownload() {
	FileDownload(light_mesh);
	for(var i = 0; i < Len(skybox_files); ++i)
		FileDownload(skybox_files[i]);
	
	FileDownload(map);
	FileDownload(mesh_src);
	
	FileDownload(grass);
	FileDownload(wall);
}

function OnInit(params) {
	outputln();
	/* initialize light */
	Sun = CVmLight();
	Sun.SetPosition(PosL);
	//Sun.SetAmbient([0.3, 0.3, 0]);
	//Sun.SetDiffuse([0.7, 0.7, 0.9]);
	//Sun.SetSpecular([0.9, 0.9, 0.9]);
	//Sun.Enable();
	
	Light0 = SpotlLight();
	var Lpo = [4,2,4];
	Light0.Initialize(Lpo);
	var l_mesh = CVmNewMesh(light_mesh);
	Light0.SetRenderableObject(l_mesh);
	Light0.Update();
	
	outputln("Sun initialized!");

	//Initialize selecction Mats
	selected_mat = CVmMaterial();
   	selected_mat.ambient   = [0.7, 0.0, 0.0, 1.0];
   	selected_mat.diffuse   = [0.8, 1.0, 0.0, 1.0];
   	selected_mat.specular  = [0.9, 0.9, 0.9, 1.0];
   	selected_mat.shininess = 5;
   	
	unselected_mat = CVmMaterial();
   	unselected_mat.ambient   = [0.6, 0.6, 0.6, 1.0];
   	unselected_mat.diffuse   = [0.7, 0.7, 0.7, 1.0];
   	unselected_mat.specular  = [0.8, 0.8, 0.8, 1.0];
   	unselected_mat.shininess = 5;
   	
	//Initialize selectable objects
	var num_seg = 30;
	var radius = 1;
	var hemisphere = 1;  //0.5= hemisphere, 1= sphere
	onMouseL = false;
	selected = array(0);
	scaling = array(0);
	selectabe_objects = array(0);
	
	var sphere_mesh = CVmNewMesh(VRP_SPHERE , num_seg, radius, hemisphere);  
	var sphere = CVmObj(sphere_mesh);
	sphere.SetPosition([5,2,5]);
	sphere.ForceMaterial(unselected_mat);
	aadd( selectabe_objects, sphere);
	aadd( selected, false );
	aadd( scaling, 1.0 );
	
	var sphere2 = CVmObj(CVmNewMesh(VRP_SPHERE , num_seg, radius, hemisphere));
	sphere2.SetPosition([5,4,5]);
	sphere2.ForceMaterial(unselected_mat);
	aadd( selectabe_objects, sphere2);
	aadd( selected, false );
	aadd( scaling, 1.0 );
	
	outputln("Objects initialized!");
	
	//Skybox Init
	var sky_textures = Array(Len(skybox_files));
	for(var i = 0; i < Len(sky_textures); ++i)
		sky_textures[i] = CVmTexture(skybox_files[i]);
	sky_box = SkyBox();
	sky_box.Initialize(sky_textures, SCENE_FAR);
	outputln("Skybox initialized!");
	
	//Terrain
	var tmp = LoadFile(map);
   	height = array(0);
   	for (var i = 0; i < Len(tmp); ++i) {
   		var line = Split(tmp[i], " ");
   		aadd(height, line);
   	}
   	
	var wall_texture = CVmTexture(wall);
	var grass_texture = CVmTexture(grass);
	
	renderable_terrain = Terrain();
	renderable_terrain.Initialize(height, grass_texture, wall_texture);
	outputln("Terrain initialized!");
	
	CameraInit(height);
	outputln("Camera initialized!");
	//OpenGl Inits
	glEnable(GL_BLEND);
	glEnable(GL_NORMALIZE);
	glEnable(GL_CULL_FACE);
	glCullFace(GL_BACK);
	glEnable(GL_LIGHTING);
	
	//var m_mesh = CVmNewMesh(mesh_src); // The mesh is created from the specified AAM file
   	//m_mesh.CenterBoundingBox();      // Mesh geometry is translated so as to put the origin in the center of the mesh bounding box
   	//m_mesh.Normalize(10); 
   	//global my_obj = CVmObj(m_mesh);
   	//my_obj.SetPosition(Lpo[0], Lpo[1], Lpo[2]+10);
   	
}

function IsSelected(object) 
{
	var viewport = glGet(GL_VIEWPORT);
	var winx = Mouse.X+1;
	var winy = viewport[3]-Mouse.Y;
	var point1=gluUnproject(winx,winy,0.0); 
	var point2=gluUnproject(winx,winy,1.0) * SCENE_FAR;
	var pInt=[0,0,0];  	//Will store the closest intersection point (to point1)
	var nrml=[0,0,0];  	//Will store the normal on that point
	var n_TR = 0; 		//Will store the triangle index
	var comp = 0; 		//Will store the component (Characters)
	if (object.IsColliding(point1,point2,&pInt, &nrml, &n_TR, &comp, true, true))
	{
		return true;
	}
	return false;
}

function ObjectToMouse(index) {
	var viewport = glGet(GL_VIEWPORT);
	var winx = Mouse.X+1;
	var winy = viewport[3]-Mouse.Y;	
	var aux = gluProject(selectabe_objects[index].GetPosition());
	var p0 = gluUnProject([winx, winy, aux[2] + Mouse.Wheel*0.001]);
	trace(p0);
	
	if (p0[0] == check_out_of_limits(p0[0], Len(height)/2) &&
		p0[2] == check_out_of_limits(p0[2], Len(height[0])/2)) {
	
		if (p0[1] > val(height[p0[0]*2][p0[2]*2]) + scaling[index])
			selectabe_objects[index].SetPosition(p0);
	}
}

function ScaleObject(index) {
	scaling[index] *= (1 + Mouse.Wheel*0.01);
	if (scaling[index] > 2)
	 	scaling[index] = 2;
	else if (scaling[index] < 1)
		scaling[index] = 1;
	selectabe_objects[index].SetScale(scaling[index]);	
}

function ScaleObjectTo1Or2(index) {
	if (scaling[index] >= 1.5)
		scaling[index] = 2;
	else if (scaling[index] < 1.5) 
		scaling[index] = 1;
	selectabe_objects[index].SetScale(scaling[index]);	
}

function DrawSelectableObjects() {
	glPushAttrib(GL_LIGHTING_BIT | GL_LINE_BIT | GL_CURRENT_BIT);
	for(var i = 0; i < Len(selectabe_objects); ++i) {
		selectabe_objects[i].Draw();
	}
	glPopAttrib();	
}

function UpdateSelectableObjects() {
	var already_selected = false;
	for(var i = 0; i < Len(selectabe_objects); ++i) {
		if(Mouse.ButtonL && !onMouseL) {
			if(!already_selected && IsSelected(selectabe_objects[i])) {
				outputln(Mouse.Wheel); //IMPORTANT, DO NOT DELETE
				selected[i] = !selected[i];
			} else {
				selected[i] = false;
			}
		}
	}
	
	if(Mouse.ButtonL) {
		onMouseL = true;
	} else {
		onMouseL = false;
	}
	
	for(var i = 0; i < Len(selectabe_objects); ++i) {
		if (selected[i]) {
			selectabe_objects[i].ForceMaterial(selected_mat);
			if (!Mouse.ButtonR) {
				ObjectToMouse(i);
				ScaleObjectTo1Or2(i);
			} else {
				ScaleObject(i);
			}
		} else {
			selectabe_objects[i].ForceMaterial(unselected_mat);
		}
	}
}

function isAnyObjectSelected() {
	for(var i = 0; i < Len(selectabe_objects); ++i)
		if(selected[i]) 
			return true;
	return false;
}

function OnFrame() {
	/* manage camera */
	if (!isAnyObjectSelected())
		CameraMoveMouse(height);
	else
		CameraStandBy();

	SceneBegin();
	
	Light0.Rotate(0, 0.1);
	Light0.Update();
	Light0.Render();
	sky_box.Render(CameraGetPosition());
	//DrawGrid([0.5, 0.5, 0.5], 100);
	renderable_terrain.DrawTerrain();
	
	UpdateSelectableObjects();
	DrawSelectableObjects();
	
	SceneEnd();
}



function DownloadReady(RequestID)
{
	// TODO
}



function OnTimer()
{
	// TODO:
}


function OnEvent(eventID, wparam, lparam){
	// TODO: put your events handling code here
}

function OnError(){
	// TODO: put your errors handling code here
}

function OnExit()
{
	// TODO: put your cleanup code here
}


